"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const commandline_1 = require("../../util/commandline");
const apis_1 = require("../../util/apis");
const interaction_1 = require("../../util/interaction");
const util_1 = require("util");
const _ = require("lodash");
const Request = require("request");
const Path = require("path");
const Pfs = require("../../util/misc/promisfied-fs");
const distribute_util_1 = require("./lib/distribute-util");
const fs = require("fs");
const debug = require("debug")("appcenter-cli:commands:distribute:release");
let ReleaseBinaryCommand = class ReleaseBinaryCommand extends commandline_1.AppCommand {
    run(client) {
        return __awaiter(this, void 0, void 0, function* () {
            const app = this.app;
            this.validateParameters();
            debug("Loading prerequisites");
            const [distributionGroupUsersCount, storeInformation, releaseBinaryFileStream, releaseBinaryFileStats, releaseNotesString] = yield interaction_1.out.progress("Loading prerequisites...", this.getPrerequisites(client));
            this.validateParametersWithPrerequisites(storeInformation);
            debug("Creating release upload");
            const createdReleaseUpload = yield this.createReleaseUpload(client, app);
            const uploadUri = createdReleaseUpload.uploadUrl;
            const uploadId = createdReleaseUpload.uploadId;
            let releaseUrl;
            try {
                debug("Uploading release binary");
                yield interaction_1.out.progress("Uploading release binary...", this.uploadFileToUri(uploadUri, releaseBinaryFileStream, releaseBinaryFileStats, Path.basename(this.filePath)));
                debug("Finishing release upload");
                releaseUrl = yield this.finishReleaseUpload(client, app, uploadId);
            }
            catch (error) {
                try {
                    interaction_1.out.text("Release upload failed");
                    yield this.abortReleaseUpload(client, app, uploadId);
                    interaction_1.out.text("Release upload was aborted");
                }
                catch (abortError) {
                    debug("Failed to abort release upload");
                }
                throw error;
            }
            debug("Extracting release ID from the release URL");
            const releaseId = this.extractReleaseId(releaseUrl);
            if (releaseNotesString && releaseNotesString.length > 0) {
                debug("Setting release notes");
                yield this.putReleaseDetails(client, app, releaseId, releaseNotesString);
            }
            else {
                debug("Skipping empty release notes");
            }
            if (!_.isNil(this.distributionGroup)) {
                debug("Distributing the release to a group");
                yield this.distributeRelease(client, app, releaseId, this.silent);
            }
            if (!_.isNil(storeInformation)) {
                debug("Distributing the release to a store");
                try {
                    yield this.publishToStore(client, app, storeInformation, releaseId);
                }
                catch (error) {
                    if (!_.isNil(this.distributionGroup)) {
                        interaction_1.out.text(`Release was successfully distributed to group '${this.distributionGroup}' but could not be published to store '${this.storeName}'.`);
                    }
                    throw error;
                }
            }
            debug("Retrieving the release");
            const releaseDetails = yield this.getDistributeRelease(client, app, releaseId);
            if (releaseDetails) {
                if (!_.isNil(this.distributionGroup)) {
                    const storeComment = (!_.isNil(this.storeName)) ? ` and to store '${this.storeName}'` : "";
                    if (_.isNull(distributionGroupUsersCount)) {
                        interaction_1.out.text((rd) => `Release ${rd.shortVersion} (${rd.version}) was successfully released to ${this.distributionGroup}${storeComment}`, releaseDetails);
                    }
                    else {
                        interaction_1.out.text((rd) => `Release ${rd.shortVersion} (${rd.version}) was successfully released to ${distributionGroupUsersCount} testers in ${this.distributionGroup}${storeComment}`, releaseDetails);
                    }
                }
                else {
                    interaction_1.out.text((rd) => `Release ${rd.shortVersion} (${rd.version}) was successfully released to store '${this.storeName}'`, releaseDetails);
                }
            }
            else {
                interaction_1.out.text(`Release was successfully released.`);
            }
            return commandline_1.success();
        });
    }
    validateParameters() {
        debug("Checking for invalid parameter combinations");
        if (!_.isNil(this.releaseNotes) && !_.isNil(this.releaseNotesFile)) {
            throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, "'--release-notes' and '--release-notes-file' switches are mutually exclusive");
        }
        if (_.isNil(this.distributionGroup) && _.isNil(this.storeName)) {
            throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, "At least one of '--group' or '--store' must be specified");
        }
        if (!_.isNil(this.distributionGroup)) {
            if ([".aab"].includes(this.fileExtension)) {
                throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `Files of type '${this.fileExtension}' can not be distributed to groups`);
            }
        }
        if (!_.isNil(this.storeName)) {
            if (![".aab", ".apk", ".ipa"].includes(this.fileExtension)) {
                throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `Files of type '${this.fileExtension}' can not be distributed to stores`);
            }
        }
        if (_.isNil(this.buildVersion)) {
            if ([".zip", ".msi"].includes(this.fileExtension)) {
                throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `--build-version parameter must be specified when uploading ${this.fileExtension} files`);
            }
        }
        if (_.isNil(this.buildNumber) || _.isNil(this.buildVersion)) {
            if ([".pkg", ".dmg"].includes(this.fileExtension)) {
                throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `--build-version and --build-number must both be specified when uploading ${this.fileExtension} files`);
            }
        }
    }
    validateParametersWithPrerequisites(storeInformation) {
        debug("Checking for invalid parameter combinations with prerequisites");
        if (storeInformation && storeInformation.type === "apple" && _.isNil(this.releaseNotes) && _.isNil(this.releaseNotesFile)) {
            throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, "At least one of '--release-notes' or '--release-notes-file' must be specified when publishing to an Apple store.");
        }
    }
    getPrerequisites(client) {
        return __awaiter(this, void 0, void 0, function* () {
            // load release binary file
            const [fileStats, fileStream] = yield this.getReleaseFileStream();
            // load release notes file or use provided release notes if none was specified
            const releaseNotesString = this.getReleaseNotesString();
            let distributionGroupUsersNumber;
            let storeInformation;
            if (!_.isNil(this.distributionGroup)) {
                // get number of distribution group users (and check distribution group existence)
                // return null if request has failed because of any reason except non-existing group name.
                distributionGroupUsersNumber = this.getDistributionGroupUsersNumber(client);
            }
            if (!_.isNil(this.storeName)) {
                // get distribution store type to check existence and further filtering
                storeInformation = this.getStoreDetails(client);
            }
            return Promise.all([distributionGroupUsersNumber, storeInformation, fileStream, fileStats, releaseNotesString]);
        });
    }
    getReleaseFileStream() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const fileStats = yield Pfs.stat(this.filePath);
                const fileStream = fs.createReadStream(this.filePath);
                return Promise.all([fileStats, fileStream]);
            }
            catch (error) {
                if (error.code === "ENOENT") {
                    throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `binary file '${this.filePath}' doesn't exist`);
                }
                else {
                    throw error;
                }
            }
        });
    }
    getReleaseNotesString() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!_.isNil(this.releaseNotesFile)) {
                try {
                    return yield Pfs.readFile(this.releaseNotesFile, "utf8");
                }
                catch (error) {
                    if (error.code === "ENOENT") {
                        throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `release notes file '${this.releaseNotesFile}' doesn't exist`);
                    }
                    else {
                        throw error;
                    }
                }
            }
            else {
                return this.releaseNotes;
            }
        });
    }
    getDistributionGroupUsersNumber(client) {
        return __awaiter(this, void 0, void 0, function* () {
            let distributionGroupUsersRequestResponse;
            try {
                distributionGroupUsersRequestResponse = yield apis_1.clientRequest((cb) => client.distributionGroups.listUsers(this.app.ownerName, this.app.appName, this.distributionGroup, cb));
                const statusCode = distributionGroupUsersRequestResponse.response.statusCode;
                if (statusCode >= 400) {
                    throw statusCode;
                }
            }
            catch (error) {
                if (error === 404) {
                    throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `distribution group ${this.distributionGroup} was not found`);
                }
                else {
                    debug(`Failed to get users of distribution group ${this.distributionGroup}, returning null - ${util_1.inspect(error)}`);
                    return null;
                }
            }
            return distributionGroupUsersRequestResponse.result.length;
        });
    }
    getStoreDetails(client) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const storeDetailsResponse = yield apis_1.clientRequest((cb) => client.stores.get(this.storeName, this.app.ownerName, this.app.appName, cb));
                const statusCode = storeDetailsResponse.response.statusCode;
                if (statusCode >= 400) {
                    throw { statusCode };
                }
                return storeDetailsResponse.result;
            }
            catch (error) {
                if (error.statusCode === 404) {
                    throw commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `store '${this.storeName}' was not found`);
                }
                else {
                    debug(`Failed to get store details for '${this.storeName}', returning null - ${util_1.inspect(error)}`);
                    return null;
                }
            }
        });
    }
    createReleaseUpload(client, app) {
        return __awaiter(this, void 0, void 0, function* () {
            let createReleaseUploadRequestResponse;
            try {
                const options = {
                    buildVersion: this.buildVersion,
                    buildNumber: this.buildNumber
                };
                createReleaseUploadRequestResponse = yield interaction_1.out.progress("Creating release upload...", apis_1.clientRequest((cb) => client.releaseUploads.create(app.ownerName, app.appName, options, cb)));
            }
            catch (error) {
                throw commandline_1.failure(commandline_1.ErrorCodes.Exception, `failed to create release upload for ${this.filePath}`);
            }
            return createReleaseUploadRequestResponse.result;
        });
    }
    uploadFileToUri(uploadUrl, fileStream, fileStats, filename) {
        debug("Uploading the release binary");
        return new Promise((resolve, reject) => {
            Request.post({
                formData: {
                    ipa: {
                        options: {
                            filename,
                            contentType: "application/octet-stream",
                            knownLength: fileStats.size
                        },
                        value: fileStream
                    }
                },
                url: uploadUrl
            })
                .on("error", (error) => {
                reject(commandline_1.failure(commandline_1.ErrorCodes.Exception, `release binary uploading failed: ${error.message}`));
            })
                .on("response", (response) => {
                if (response.statusCode < 400) {
                    resolve();
                }
                else {
                    reject(commandline_1.failure(commandline_1.ErrorCodes.Exception, `release binary file uploading failed: HTTP ${response.statusCode} ${response.statusMessage}`));
                }
            });
        });
    }
    finishReleaseUpload(client, app, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let finishReleaseUploadRequestResponse;
            try {
                finishReleaseUploadRequestResponse = yield interaction_1.out.progress("Finishing release upload...", apis_1.clientRequest((cb) => client.releaseUploads.complete(uploadId, app.ownerName, app.appName, "committed", cb)));
            }
            catch (error) {
                throw commandline_1.failure(commandline_1.ErrorCodes.Exception, `failed to finish release upload for ${this.filePath}`);
            }
            return finishReleaseUploadRequestResponse.result.releaseUrl;
        });
    }
    abortReleaseUpload(client, app, uploadId) {
        return __awaiter(this, void 0, void 0, function* () {
            let abortReleaseUploadRequestResponse;
            try {
                abortReleaseUploadRequestResponse = yield interaction_1.out.progress("Aborting release upload...", apis_1.clientRequest((cb) => client.releaseUploads.complete(uploadId, app.ownerName, app.appName, "aborted", cb)));
            }
            catch (error) {
                throw new Error(`HTTP ${abortReleaseUploadRequestResponse.response.statusCode} - ${abortReleaseUploadRequestResponse.response.statusMessage}`);
            }
        });
    }
    extractReleaseId(releaseUrl) {
        const releaseId = Number(_(releaseUrl).split("/").last());
        console.assert(Number.isSafeInteger(releaseId) && releaseId > 0, `API returned unexpected release URL: ${releaseUrl}`);
        return releaseId;
    }
    getDistributeRelease(client, app, releaseId) {
        return __awaiter(this, void 0, void 0, function* () {
            let releaseRequestResponse;
            try {
                releaseRequestResponse = yield interaction_1.out.progress(`Retrieving the release...`, apis_1.clientRequest((cb) => __awaiter(this, void 0, void 0, function* () {
                    return client.releases.getLatestByUser(releaseId.toString(), app.ownerName, app.appName, cb);
                })));
            }
            catch (error) {
                if (error === 400) {
                    throw commandline_1.failure(commandline_1.ErrorCodes.Exception, "release_id is not an integer or the string latest");
                }
                else if (error === 404) {
                    throw commandline_1.failure(commandline_1.ErrorCodes.Exception, `The release ${releaseId} can't be found`);
                }
                else {
                    return null;
                }
            }
            return releaseRequestResponse.result;
        });
    }
    putReleaseDetails(client, app, releaseId, releaseNotesString) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { result, response } = yield interaction_1.out.progress(`Updating release details...`, apis_1.clientRequest((cb) => __awaiter(this, void 0, void 0, function* () {
                    return client.releases.updateDetails(releaseId, app.ownerName, app.appName, {
                        releaseNotes: releaseNotesString,
                    }, cb);
                })));
                const statusCode = response.statusCode;
                if (statusCode >= 400) {
                    debug(`Got error response: ${util_1.inspect(response)}`);
                    throw statusCode;
                }
                return result;
            }
            catch (error) {
                if (error === 400) {
                    throw commandline_1.failure(commandline_1.ErrorCodes.Exception, "failed to set the release notes");
                }
                else {
                    debug(`Failed to distribute the release - ${util_1.inspect(error)}`);
                    throw commandline_1.failure(commandline_1.ErrorCodes.Exception, `failed to set release notes for release ${releaseId}`);
                }
            }
        });
    }
    distributeRelease(client, app, releaseId, silent) {
        return __awaiter(this, void 0, void 0, function* () {
            const distributionGroupResponse = yield distribute_util_1.getDistributionGroup({
                client, releaseId, app: this.app, destination: this.distributionGroup, destinationType: "group"
            });
            yield distribute_util_1.addGroupToRelease({
                client, releaseId, distributionGroup: distributionGroupResponse, app: this.app, destination: this.distributionGroup, destinationType: "group", mandatory: false, silent: silent
            });
        });
    }
    publishToStore(client, app, storeInformation, releaseId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { result, response } = yield interaction_1.out.progress(`Publishing to store '${storeInformation.name}'...`, apis_1.clientRequest((cb) => __awaiter(this, void 0, void 0, function* () { return client.releases.addStore(releaseId, app.ownerName, app.appName, storeInformation.id, cb); })));
                const statusCode = response.statusCode;
                if (statusCode >= 400) {
                    throw result;
                }
                return result;
            }
            catch (error) {
                debug(`Failed to distribute the release to store - ${util_1.inspect(error)}`);
                throw commandline_1.failure(commandline_1.ErrorCodes.Exception, error.message);
            }
        });
    }
    get fileExtension() {
        return Path.parse(this.filePath).ext.toLowerCase();
    }
};
__decorate([
    commandline_1.help("Path to binary file"),
    commandline_1.shortName("f"),
    commandline_1.longName("file"),
    commandline_1.required,
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "filePath", void 0);
__decorate([
    commandline_1.help("Build version parameter required for .zip, .msi, .pkg and .dmg files"),
    commandline_1.shortName("b"),
    commandline_1.longName("build-version"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "buildVersion", void 0);
__decorate([
    commandline_1.help("Build number parameter required for macOS .pkg and .dmg files"),
    commandline_1.shortName("n"),
    commandline_1.longName("build-number"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "buildNumber", void 0);
__decorate([
    commandline_1.help("Distribution group name"),
    commandline_1.shortName("g"),
    commandline_1.longName("group"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "distributionGroup", void 0);
__decorate([
    commandline_1.help("Store name"),
    commandline_1.shortName("s"),
    commandline_1.longName("store"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "storeName", void 0);
__decorate([
    commandline_1.help("Release notes text"),
    commandline_1.shortName("r"),
    commandline_1.longName("release-notes"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "releaseNotes", void 0);
__decorate([
    commandline_1.help("Path to release notes file"),
    commandline_1.shortName("R"),
    commandline_1.longName("release-notes-file"),
    commandline_1.hasArg
], ReleaseBinaryCommand.prototype, "releaseNotesFile", void 0);
__decorate([
    commandline_1.help("Do not notify testers of this release"),
    commandline_1.longName("silent")
], ReleaseBinaryCommand.prototype, "silent", void 0);
ReleaseBinaryCommand = __decorate([
    commandline_1.help("Upload release binary and trigger distribution, at least one of --store or --group must be specified")
], ReleaseBinaryCommand);
exports.default = ReleaseBinaryCommand;
