"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var const_1 = require("../../const");
var telemetry_1 = require("../telemetry");
var request_1 = require("../request");
var types_1 = require("../../types");
var urlParse = require('url-parse');
var errorUtils = require("../file-upload-error");
var ControllerMetadataRequest = /** @class */ (function () {
    function ControllerMetadataRequest(controller) {
        this.controller = controller;
        if (!controller) {
            throw errorUtils.fileUploadError("Controller must be specified");
        }
    }
    ControllerMetadataRequest.prototype.run = function () {
        var _this = this;
        this.controller.log("Setting metadata for AssetId:  " + this.controller.uploadData.assetId);
        this.controller.log("File name: " + this.controller.uploadData.file.name);
        this.controller.log("File size: " + this.controller.uploadData.file.size);
        this.controller.log("CorrelationId: " + this.controller.uploadData.correlationId);
        this.controller.message('Setting asset metadata on server');
        var parsedUrl = urlParse(this.controller.uploadData.uploadDomain
            + types_1.UploadBaseUrls.SetMetadata
            + this.controller.uploadData.assetId, true);
        parsedUrl.query["file_name"] = this.controller.uploadData.file.name;
        parsedUrl.query["file_Size"] = this.controller.uploadData.file.size.toString();
        parsedUrl.query["token"] = this.controller.uploadData.token;
        request_1.default({
            method: "POST",
            async: true,
            url: parsedUrl.toString(),
            correlationId: this.controller.uploadData.correlationId,
            correlationVector: this.controller.uploadData.correlationVector,
            onError: function (error) {
                var eventStatusCode = error.event && error.event.currentTarget && error.event.currentTarget.status ? error.event.currentTarget.status : "none";
                _this.controller.log("Set metadata failed: AssetId: " + _this.controller.uploadData.assetId + ", StatusCode: " + eventStatusCode + ", errorMessage: " + error.message);
                _this.controller.fatalError(const_1.failToUploadMsg, {
                    AssetId: _this.controller.uploadData.assetId,
                    CorrelationId: _this.controller.uploadData.correlationId,
                    message: 'Set metadata failed',
                    errorMessage: error.message ? error.message : 'none',
                    fileName: _this.controller.uploadData.file.name,
                    fileSize: _this.controller.uploadData.file.size,
                    eventStatusCode: eventStatusCode
                });
            },
            onSuccess: this.onSetMetaDataSuccess.bind(this),
        });
    };
    ControllerMetadataRequest.prototype.onSetMetaDataSuccess = function (response) {
        if (response.error) {
            this.controller.log(response.message || response.data.message);
            this.controller.fatalError(response.message || response.data.message, {
                AssetId: this.controller.uploadData.assetId,
                CorrelationId: this.controller.uploadData.correlationId,
            });
            return;
        }
        this.controller.message('Set metadata completed.');
        this.controller.log("ChunkSize: " + response.data.chunk_size);
        this.controller.uploadData.chunkSize = response.data.chunk_size;
        this.controller.uploadData.blobPartitions = response.data.blob_partitions;
        // Calculate the number of chunks to send
        this.controller.uploadData.totalBlocks = Math.ceil(this.controller.uploadData.file.size / this.controller.uploadData.chunkSize);
        this.controller.progressUpdateRate = Math.ceil(this.controller.uploadData.totalBlocks / 100);
        this.controller.log("Chunks to upload: " + this.controller.uploadData.totalBlocks);
        telemetry_1.trackEvent('setMetaDataSuccess', {
            chunckSize: this.controller.uploadData.chunkSize,
            blobPartitions: this.controller.uploadData.blobPartitions,
            totalBlocks: this.controller.uploadData.totalBlocks,
            progressUpdateRate: this.controller.progressUpdateRate,
            AssetId: this.controller.uploadData.assetId,
            CorrelationId: this.controller.uploadData.correlationId
        });
        this.controller.enqueueChunks(response.data.chunk_list);
        // Handle the restart/resume/recovery scenario
        if (response.data.resume_restart) {
            this.controller.setState(types_1.FileUploadServiceState.ResumeOrRestart);
            var remainingChunksToUpload = response.data.chunk_list.length;
            this.controller.log("Chunks remaining to upload: " + remainingChunksToUpload);
            this.controller.uploadStatus.blocksCompleted = this.controller.uploadData.totalBlocks - remainingChunksToUpload;
        }
        else {
            this.controller.setState(types_1.FileUploadServiceState.Initialized);
            this.controller.uploadStatus.blocksCompleted = 0;
            this.controller.uploadStatus.startTime = new Date();
            this.controller.healthCheck();
        }
    };
    return ControllerMetadataRequest;
}());
exports.default = ControllerMetadataRequest;
//# sourceMappingURL=metadata.js.map