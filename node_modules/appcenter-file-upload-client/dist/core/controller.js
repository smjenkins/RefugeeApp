"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../types");
var utils_1 = require("../utils");
var cancel_1 = require("./controller-requests/cancel");
var finish_1 = require("./controller-requests/finish");
var metadata_1 = require("./controller-requests/metadata");
var init_state_1 = require("./init-state");
var metrics_1 = require("./metrics");
var telemetry_1 = require("./telemetry");
var isNode = require("detect-node");
var FileUploadController = /** @class */ (function () {
    function FileUploadController(uploadData) {
        this.initializeUpload(uploadData);
    }
    FileUploadController.prototype.init = function (uploadData) {
        this.initializeUpload(uploadData);
    };
    FileUploadController.prototype.start = function (_file) {
        var file = null;
        if (isNode) {
            var fs = require("fs");
            var path = require("path");
            file = {
                name: path.basename(_file),
                size: fs.statSync(_file).size,
                filePath: _file
            };
        }
        else {
            file = _file;
        }
        if (!file || file.size <= 0) {
            this.message('A file must be specified and must not be empty.');
            return;
        }
        if (this.isUploadInProgress()) {
            this.message('Cannot start an upload that is already in progress.');
            return;
        }
        this.uploadData.file = file;
        this.setMetadata();
    };
    FileUploadController.prototype.cancel = function () {
        new cancel_1.default(this).run();
    };
    FileUploadController.prototype.upload = function () {
        return;
    };
    FileUploadController.prototype.enqueueChunks = function (chunks) {
        // if the queue is empty then just add all the chunks
        if (this.uploadStatus.chunkQueue.length === 0) {
            this.uploadStatus.chunkQueue = chunks;
            return;
        }
        // if there something in the queue don't re-add a chunk. This
        // can result in more than one thread uploading the same chunk
        var me = this;
        this.uploadStatus.chunkQueue.concat(chunks.filter(function (chunk) {
            return me.uploadStatus.chunkQueue.indexOf(chunk) < 0;
        }));
    };
    FileUploadController.prototype.healthCheck = function () {
        throw new Error("Method should be implemented in subclasses");
    };
    FileUploadController.prototype.fatalError = function (errorMessage, data) {
        this.setState(types_1.FileUploadServiceState.FatalError);
        telemetry_1.trackError(errorMessage, data);
        if (this.uploadData.onMessage) {
            this.uploadData.onMessage(errorMessage, types_1.MessageLevel.Error);
        }
    };
    FileUploadController.prototype.log = function (information) {
        if (this.uploadData.logToConsole === true) {
            console.log(utils_1.timeStamp() + ": " + information);
        }
        if (this.uploadData.onMessage) {
            this.uploadData.onMessage(information, types_1.MessageLevel.Verbose);
        }
    };
    FileUploadController.prototype.message = function (text, level) {
        if (!level) {
            level = types_1.MessageLevel.Information;
        }
        if (this.uploadData.onMessage) {
            this.uploadData.onMessage(text, level);
        }
    };
    FileUploadController.prototype.setState = function (state) {
        this.uploadStatus.state = state;
        this.log("Setting state: " + types_1.FileUploadServiceState[state] + " (" + state + ")");
        if (this.uploadData.onStateChanged) {
            this.uploadData.onStateChanged(state);
        }
    };
    FileUploadController.prototype.stopAllWorkers = function () {
        // Is overriden for multithreaduploader
        return;
    };
    FileUploadController.prototype.isUploadInProgress = function () {
        return this.uploadStatus.state === types_1.FileUploadServiceState.Initialized ||
            this.uploadStatus.state === types_1.FileUploadServiceState.Uploading ||
            this.uploadStatus.state === types_1.FileUploadServiceState.Verifying;
    };
    FileUploadController.prototype.reportChunkProgress = function () {
        if (!this.uploadData.onProgressChanged) {
            return;
        }
        var percentCompleted = this.uploadStatus.blocksCompleted * 100 / this.uploadData.totalBlocks;
        // Since workers that are on async processes can't be aborted there is a chance
        // that a chunk will be inflight and account as missing so when it gets resent
        // it will get accounted twice, since accounting for inflight chunks on the percentage
        // calculation is not reliable if we go over 100 we'll just mark it as 100.
        if (percentCompleted > 100) {
            percentCompleted = 100;
        }
        this.uploadStatus.averageSpeed = metrics_1.calculateAverageSpeedWithChunks(this.uploadStatus.startTime, this.uploadStatus.blocksCompleted, this.uploadData.chunkSize);
        var timeRemainingIsInvalid = this.uploadStatus.averageSpeed === 0 && (this.uploadStatus.chunkQueue.length * this.uploadData.chunkSize > 0);
        if (timeRemainingIsInvalid) {
            this.log("something went wrong averageSpeed is 0 but the dataRemaining is: " + this.uploadStatus.chunkQueue.length * this.uploadData.chunkSize);
        }
        var timeRemaining = metrics_1.calculateTimeRemainingWithChunks(this.uploadData.totalBlocks - this.uploadStatus.blocksCompleted, this.uploadData.chunkSize, this.uploadStatus.averageSpeed);
        var progress = {
            percentCompleted: parseFloat(percentCompleted.toFixed(2)),
            averageSpeedInMbps: parseFloat(this.uploadStatus.averageSpeed.toFixed(2)),
            secondsRemaining: parseInt(timeRemaining.toFixed(0), 10)
        };
        this.uploadData.onProgressChanged(progress);
    };
    FileUploadController.prototype.reportEventProgress = function (chunkNumber, event) {
        if (!this.uploadData.onProgressChanged || !event.lengthComputable) {
            return;
        }
        var bytesUploadedInChunk = event.loaded;
        var previousBytesUploadedInChunk = this.chunkBytesUploaded[chunkNumber - 1] || 0;
        var difference = bytesUploadedInChunk - previousBytesUploadedInChunk;
        if (difference > 0) {
            this.totalBytesUploaded += difference;
            this.chunkBytesUploaded[chunkNumber - 1] = bytesUploadedInChunk;
            var percentCompleted = this.totalBytesUploaded * 100 / this.uploadData.file.size;
            var averageSpeed = metrics_1.calculateAverageSpeed(this.uploadStatus.startTime, this.totalBytesUploaded);
            var bytesRemaining = this.uploadData.file.size - this.totalBytesUploaded;
            var timeRemaining = metrics_1.calculateTimeRemaining(bytesRemaining, averageSpeed);
            var progress = {
                percentCompleted: parseFloat(percentCompleted.toFixed(2)),
                averageSpeedInMbps: parseFloat(averageSpeed.toFixed(2)),
                secondsRemaining: parseInt(timeRemaining.toFixed(0), 10)
            };
            this.uploadData.onProgressChanged(progress);
        }
    };
    FileUploadController.prototype.finishUpload = function () {
        new finish_1.default(this).run();
    };
    FileUploadController.prototype.setMetadata = function () {
        new metadata_1.default(this).run();
    };
    FileUploadController.prototype.initializeUpload = function (uploadData) {
        this.progressUpdateRate = 0;
        this.totalBytesUploaded = 0;
        this.chunkBytesUploaded = [];
        // Initialize all retry flags for the new upload.
        this.uploadStatus = init_state_1.getInitialUploadStatus();
        // Copy all the required settings on to the upload data.
        this.uploadData = init_state_1.getInitialUploadData(uploadData);
        this.setState(types_1.FileUploadServiceState.New);
        telemetry_1.trackEvent("UploadInitialized", { AssetId: this.uploadData.assetId, CorrelationId: this.uploadData.correlationId });
        this.log("Upload Initialized");
    };
    return FileUploadController;
}());
exports.default = FileUploadController;
//# sourceMappingURL=controller.js.map